---
description: Lineamientos para el uso de ActiveModelSerializers, especialmente cuando se usan serializers anidados (segundo y tercer nivel).
globs:
alwaysApply: true
---
# Serializers and Nested Serializers Best Practices

Esta regla documenta las mejores pr√°cticas para el uso de ActiveModelSerializers, especialmente cuando se usan serializers anidados (segundo y tercer nivel).

## Problema Com√∫n: Serializers Anidados con `belongs_to`

### ‚ùå Problema Frecuente

Cuando un serializer se reutiliza en diferentes niveles (ej: `BasicJobSerializer` usado dentro de `AiHuntSerializer`), las asociaciones `belongs_to` con condiciones `if:` fallan:

### ‚ùå Problema Frecuente
Cuando un serializer se reutiliza en diferentes niveles (ej: `BasicJobSerializer` usado dentro de `AiHuntSerializer`), las asociaciones `belongs_to` con condiciones `if:` fallan:

```ruby
# ‚ùå PROBLEM√ÅTICO en serializers anidados
class BasicJobSerializer < ActiveModel::Serializer
  belongs_to :location, if: -> { object.location.present? }
  belongs_to :client, if: -> { object.client.present? }
end
```

### üîç Por qu√© ocurre:
1. **Evaluaci√≥n prematura**: ActiveModelSerializers eval√∫a `if:` ANTES del eager loading
2. **Contexto anidado**: Dentro de serializers anidados, `object.association` puede no estar cargado
3. **Lazy loading conflictivo**: Rails intenta hacer queries adicionales que rompen el contexto

## ‚úÖ Soluciones Recomendadas

### **Soluci√≥n 1: Atributos Custom (RECOMENDADO)**
Reemplazar `belongs_to` con atributos custom para asociaciones problem√°ticas:

```ruby
# ‚úÖ ROBUSTO - Funciona en cualquier nivel de anidaci√≥n
class BasicJobSerializer < ActiveModel::Serializer
  # En lugar de: belongs_to :location, if: -> { object.location.present? }
  attribute :location do
    if object.location.present?
      {
        id: object.location.id,
        name: object.location.name,
        city: object.location.city,
        country: object.location.country,
        latitude: object.location.latitude&.to_f,
        longitude: object.location.longitude&.to_f
      }
    else
      nil
    end
  end

  # En lugar de: belongs_to :client, if: -> { object.client.present? }
  attribute :client do
    if object.client.present?
      {
        id: object.client.id,
        name: object.client.name,
        industry: object.client.industry&.name,
        company_size: object.client.company_size
        # ... otros campos necesarios
      }
    else
      nil
    end
  end
end
```

### **Soluci√≥n 2: Quitar Condiciones `if:`**
Para casos simples, quitar la condici√≥n ya que AMS maneja `nil` autom√°ticamente:

```ruby
# ‚úÖ SIMPLE - AMS maneja nil autom√°ticamente
belongs_to :location  # Sin if: condition
```

### **Soluci√≥n 3: Condiciones con Foreign Keys**
Si necesitas condici√≥n, usar foreign keys en lugar de la asociaci√≥n:

```ruby
# ‚úÖ SEGURO - foreign keys siempre disponibles
belongs_to :location, if: -> { object.location_id.present? }
```

### **Soluci√≥n 4: Include Conditional (AVANZADA)**
Para casos complejos con m√∫ltiples condiciones:

```ruby
class BasicJobSerializer < ActiveModel::Serializer
  def attributes(*args)
    data = super
    data[:location] = location_data if include_location?
    data[:client] = client_data if include_client?
    data
  end

  private

  def include_location?
    object.location_id.present?
  end

  def location_data
    LocationSerializer.new(object.location).as_json
  end

  def include_client?
    object.client_id.present?
  end

  def client_data
    BasicClientSerializer.new(object.client).as_json
  end
end
```

## üéØ Cu√°ndo Aplicar

- **Primer nivel**: `belongs_to` generalmente funciona bien
- **Segundo nivel**: Problemas empiezan a aparecer con condiciones `if:`
- **Tercer nivel**: Casi siempre requiere atributos custom

## üìã Checklist para Serializers Reutilizables

- [ ] ¬øSe usa el serializer en m√∫ltiples niveles?
- [ ] ¬øTiene asociaciones con condiciones `if: -> { object.association.present? }`?
- [ ] ¬øSe reportan asociaciones como `null` en nested contexts?
- [ ] Si s√≠ ‚Üí Convertir a atributos custom

## üí° Tips Adicionales

### 1. **Eager Loading en Controladores**
Siempre incluir asociaciones necesarias:
```ruby
base_scope.includes(
  :requested_by,
  :completed_by,
  job: [:location, :client, :created_by, :job_recruiters, :job_languages, :job_fee]
)
```

### 2. **Performance y Control**
- Atributos custom permiten control fino sobre qu√© campos incluir
- Evitan N+1 queries cuando est√°n bien implementados
- M√°s predecibles que `belongs_to` anidados

### 3. **Debugging**
- Atributos custom son m√°s f√°ciles de debuggear
- Puedes agregar logs dentro del bloque para debugging
- Errores m√°s claros y espec√≠ficos

### 4. **Consistencia**
- Una vez que conviertes una asociaci√≥n a atributo custom, mant√©n esa estrategia
- Documenta qu√© serializers usan qu√© estrategia
- Considera crear serializers espec√≠ficos para diferentes contextos si es necesario

## üö® Se√±ales de Alerta

- Asociaciones aparecen como `null` en respuestas anidadas
- Queries N+1 inesperadas en serializers anidados
- Errores de "association not loaded" en testing
- Comportamiento inconsistente entre primer nivel y niveles anidados

## üìù Ejemplos de Refactoring

### Antes (Problem√°tico):
```ruby
class BasicJobSerializer < ActiveModel::Serializer
  belongs_to :location, if: -> { object.location.present? }
  belongs_to :client, if: -> { object.client.present? }
  belongs_to :created_by, if: -> { object.created_by.present? }
end
```

### Despu√©s (Robusto):
```ruby
class BasicJobSerializer < ActiveModel::Serializer
  # Asociaciones simples sin condiciones funcionan bien
  belongs_to :created_by, serializer: BasicUserSerializer

  # Asociaciones complejas como atributos custom
  attribute :location do
    if object.location.present?
      {
        id: object.location.id,
        name: object.location.name,
        city: object.location.city,
        country: object.location.country
      }
    end
  end

  attribute :client do
    if object.client.present?
      {
        id: object.client.id,
        name: object.client.name,
        industry: object.client.industry&.name
      }
    end
  end
end
```
description:
globs:
alwaysApply: false
---
